# NetMonitor 2.0 — Monorepo & Shared Codebase Plan

**Date:** 2026-02-17  
**Status:** Draft  
**Author:** Daneel (planning), Blake (review)  
**Bead:** NetMonitor-iOS-hib

---

## 1. Executive Summary

NetMonitor currently exists as two separate repositories with significant code duplication:

- **~/Projects/NetMonitor** — macOS app ("NetMonitor Pro"), on App Store
- **~/Projects/NetMonitor-iOS** — iOS app ("Netmonitor"), 1.0 just submitted to App Store

Both apps share ~60% of their non-UI code but have diverged independently. The iOS codebase is newer, more refined, and uses modern patterns (protocol-based DI, `@Observable`, ICMP-first with TCP fallback). The macOS app uses older patterns (shell-based ping, `ContinuationTracker`, thinner service layer).

**Goal:** Consolidate into a single monorepo with shared SPM packages, eliminating divergence while preserving platform-specific capabilities.

---

## 2. Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                    NetMonitor Monorepo                           │
│                ~/Projects/NetMonitor-2.0                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌────────────────────┐              ┌────────────────────┐     │
│  │  NetMonitor-macOS/  │              │  NetMonitor-iOS/    │     │
│  │  (Xcode target)    │              │  (Xcode target)    │     │
│  │                    │              │                    │     │
│  │  • App entry point │              │  • App entry point │     │
│  │  • macOS Views     │              │  • iOS Views       │     │
│  │  • MenuBar         │              │  • Widget          │     │
│  │  • macOS Settings  │              │  • iOS Settings    │     │
│  │  • CoreWLAN WiFi   │              │  • NEHotspot WiFi  │     │
│  │  • Sidebar nav     │              │  • Tab nav         │     │
│  └────────┬───────────┘              └────────┬───────────┘     │
│           │                                   │                 │
│           └──────────┐      ┌─────────────────┘                 │
│                      ▼      ▼                                   │
│  ┌─────────────────────────────────────────────────────┐        │
│  │              Packages/NetMonitorCore                 │        │
│  │              (SPM library)                          │        │
│  │                                                     │        │
│  │  Services/        Models/         Utilities/        │        │
│  │  ├─ PingService   ├─ ToolModels   ├─ NetworkUtils   │        │
│  │  ├─ Traceroute    ├─ NetworkMdls  ├─ ServiceUtils   │        │
│  │  ├─ DNSLookup     ├─ Enums        ├─ Theme (base)   │        │
│  │  ├─ PortScanner   ├─ LocalDevice  │                 │        │
│  │  ├─ WHOIS         ├─ ToolResult   │                 │        │
│  │  ├─ WakeOnLAN     ├─ Companion*   │                 │        │
│  │  ├─ ICMPSocket    │               │                 │        │
│  │  ├─ Bonjour       │               │                 │        │
│  │  ├─ SpeedTest     │               │                 │        │
│  │  ├─ MACVendor     │               │                 │        │
│  │  ├─ NetworkMon    │               │                 │        │
│  │  ├─ Notification  │               │                 │        │
│  │  └─ Protocols     │               │                 │        │
│  └─────────────────────┬───────────────────────────────┘        │
│                        │                                        │
│                        ▼                                        │
│  ┌─────────────────────────────────────────────────────┐        │
│  │              Packages/NetworkScanKit                 │        │
│  │              (SPM library — already exists on iOS)  │        │
│  │                                                     │        │
│  │  ScanEngine       Phases/         ConnectionBudget  │        │
│  │  ScanPipeline     ├─ ARPScan      ScanAccumulator   │        │
│  │  ScanContext       ├─ BonjourScan  ScanPhase         │        │
│  │  DiscoveredDevice ├─ ICMPLatency  RTTTracker        │        │
│  │  DeviceNameRes.   ├─ ReverseDNS   ThermalThrottle   │        │
│  │  IPv4Helpers      ├─ SSDPScan     ResumeState       │        │
│  │  ARPCacheScanner  └─ TCPProbe                       │        │
│  └─────────────────────────────────────────────────────┘        │
│                                                                 │
│  ┌─────────────────────────────────────────────────────┐        │
│  │              Tests/                                  │        │
│  │  NetMonitorCoreTests/   NetworkScanKitTests/        │        │
│  │  NetMonitor-macOSTests/ NetMonitor-iOSTests/        │        │
│  └─────────────────────────────────────────────────────┘        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3. Codebase Analysis Matrix

### 3.1 Services

| Service | macOS | iOS | Same? | Winner | Notes |
|---------|-------|-----|-------|--------|-------|
| **ICMPSocket** | ✅ 407 lines | ✅ 407 lines | **Identical** | Either | Byte-for-byte identical. Direct share. |
| **TracerouteService** | ✅ 345 lines | ✅ 349 lines | ~95% same | iOS | iOS uses `ServiceUtilities.resolveHostnameSync()` (shared utility). macOS has inline `resolveHostname()`. TracerouteHop has slightly different field names (`latencies` vs `times`). |
| **PingService** | ✅ 235 lines (`ProcessPingService`) | ✅ 294 lines (`PingService`) | **Different approach** | iOS | macOS shells out to `/sbin/ping` (sandbox constraint). iOS uses native ICMP socket + TCP fallback. iOS version is the correct approach for 2.0 — macOS should adopt it (ICMP sockets work on macOS too when not sandboxed, and the TCP fallback handles sandbox). |
| **PortScannerService** | ✅ 117 lines (`PortScanService`) | ✅ 106 lines (`PortScannerService`) | ~70% same | iOS | iOS uses `ConnectionBudget` for throttling, `ResumeState` for safe continuation management. macOS uses simple `ContinuationTracker`. Different result types (`isOpen: Bool` vs `PortState` enum). |
| **WHOISService** | — | ✅ 208 lines | iOS only | iOS | macOS has no WHOIS service (only a View that calls out). |
| **DNSLookupService** | — | ✅ 415 lines | iOS only | iOS | macOS has only a View with no backend service. Full `dnssd` + `getaddrinfo` implementation on iOS. |
| **WakeOnLANService** | ✅ 136 lines | ✅ 125 lines | ~80% same | iOS | Both send magic packets via UDP. iOS uses `@MainActor @Observable`, `ResumeState`. macOS uses `actor`, throws errors. Core logic identical. |
| **SpeedTestService** | ✅ 188 lines | ✅ 234 lines | ~60% same | iOS | iOS uses parallel streams (6 down, 4 up) with `AtomicInt64` — saturates link properly. macOS is sequential single-stream. |
| **BonjourDiscoveryService** | ✅ 521 lines | ✅ 296 lines | ~40% same | macOS (fuller) | macOS has richer resolution, TXT parsing. iOS has cleaner async API. Need to merge best of both. |
| **DeviceDiscoveryService** | ✅ 34 lines (stub) | ✅ 225 lines | Different | iOS | macOS is a placeholder. iOS has full `NetworkScanKit` integration. |
| **MACVendorLookupService** | ✅ 298 lines | ✅ 66 lines | Different | macOS | macOS has bundled OUI database + file-based lookup. iOS uses API calls. Bundled DB is better (offline, faster). |
| **NetworkMonitorService** | ✅ 35 lines | ✅ 75 lines | Similar | iOS | Both use NWPathMonitor. iOS has richer state tracking. |
| **NotificationService** | ✅ 155 lines | ✅ 167 lines | ~60% same | Merge | macOS uses `NSUserNotification` patterns. iOS uses `UNUserNotification`. Platform-specific by nature but shared logic possible. |
| **WiFi/NetworkInfoService** | ✅ 128 lines (`NetworkInfoService`) | ✅ 166 lines (`WiFiInfoService`) | **Platform-specific** | Both | macOS uses `CoreWLAN` (much richer: RSSI, channel, band, tx rate). iOS uses `NEHotspotNetwork` + `CNCopyCurrentNetworkInfo`. Must remain platform-specific behind shared protocol. |
| **CompanionService** | ✅ (server side) | ✅ (`MacConnectionService`) | Complementary | Both | macOS is the server, iOS is the client. `CompanionMessage` protocol exists in `NetMonitorShared` already. |

### 3.2 Models

| Model | macOS | iOS | Same? | Notes |
|-------|-------|-----|-------|-------|
| **Enums** (ConnectionType, DeviceType, etc.) | `NetMonitorShared/Enums.swift` (3 enums, minimal) | `Enums.swift` (12+ enums, rich) | iOS far richer | iOS has: DeviceType (13 cases w/ icons), StatusType, DeviceStatus, ConnectionType, ToolType, TargetProtocol, DNSRecordType, PortScanPreset, PortRange. macOS shared has: ConnectionType (4 cases, different raw values!), TargetProtocol, DeviceType (10 cases). **Conflict:** `ConnectionType.wifi` has rawValue `"WiFi"` on macOS, `"wifi"` on iOS. |
| **LocalDevice** | ✅ SwiftData `@Model` (11 properties) | ✅ SwiftData `@Model` (17 properties) | ~60% overlap | iOS has more fields: `status` (enum), `lastLatency`, `isGateway`, `supportsWakeOnLan`, `resolvedHostname`, `manufacturer`, `openPorts`, `discoveredServices`. macOS has simpler `isOnline: Bool`. |
| **ToolModels** (PingResult, TracerouteHop, etc.) | Defined inline in services/views | ✅ Dedicated `ToolModels.swift` (283 lines) | iOS much better | iOS has proper Identifiable, Sendable structs for all tools. macOS `PingResult` is a different struct (aggregate stats, not per-ping). macOS `TracerouteHop` has `latencies` field; iOS has `times`. |
| **NetworkModels** (WiFiInfo, GatewayInfo, ISPInfo) | Scattered / inline | ✅ Dedicated `NetworkModels.swift` (210 lines) | iOS better organized | iOS has clean data models. macOS has `ConnectionInfo` struct in NetworkInfoService. |
| **CompanionMessage** | ✅ In `NetMonitorShared` SPM | ✅ Duplicated in `Models/` | Diverged copies | Originally shared; iOS copied and evolved independently. Must re-unify. |
| **NavigationSection** | ✅ macOS specific | — | macOS only | Sidebar navigation model |
| **NetworkTarget/SessionRecord** | ✅ macOS only (monitoring) | — | macOS only | Target monitoring data model (macOS core feature) |
| **MonitoringTarget** | — | ✅ iOS only | iOS only | Simplified monitoring target |
| **ToolActivityLog** | — | ✅ iOS only | iOS only | Tool usage logging |

### 3.3 Utilities

| Utility | macOS | iOS | Same? | Notes |
|---------|-------|-----|-------|-------|
| **NetworkUtilities** | — | ✅ 193 lines | iOS only | IPv4 network detection, subnet calc, host enumeration. macOS has equivalent logic scattered in services. |
| **ServiceUtilities** | — | ✅ 73 lines | iOS only | IP validation, DNS resolution helpers. macOS has these inline in TracerouteService. |
| **ContinuationTracker** | ✅ `Utilities/` | — | macOS only | Thread-safe single-resume guard. iOS uses `ResumeState` actor (in NetworkScanKit) instead. |
| **ResumeState** | — | ✅ In NetworkScanKit | iOS only | Actor-based replacement for ContinuationTracker. Better design — eliminates data races. |
| **AppSettings** | — | ✅ iOS only | | iOS UserDefaults wrapper |
| **TargetManager** | — | ✅ iOS only | | Recent targets tracking |
| **Theme/ThemeManager** | ✅ `AppearanceEnvironment` | ✅ `Theme.swift` + `ThemeManager` | Different | Both have theming but different approaches. iOS has richer Theme enum. |
| **GlassCard** | — | ✅ iOS only | | iOS custom glass-morphism component |

### 3.4 ViewModels

| ViewModel | macOS | iOS | Notes |
|-----------|-------|-----|-------|
| **DashboardViewModel** | — (logic in View) | ✅ | iOS has proper MVVM separation |
| **PingToolViewModel** | — (logic in View) | ✅ | |
| **TracerouteToolViewModel** | — (logic in View) | ✅ | |
| **DNSLookupToolViewModel** | — (logic in View) | ✅ | |
| **PortScannerToolViewModel** | — (logic in View) | ✅ | |
| **WHOISToolViewModel** | — (logic in View) | ✅ | |
| **WakeOnLANToolViewModel** | — (logic in View) | ✅ | |
| **SpeedTestToolViewModel** | — (logic in View) | ✅ | |
| **BonjourDiscoveryToolViewModel** | — (logic in View) | ✅ | |
| **DeviceDetailViewModel** | — (logic in View) | ✅ | |
| **NetworkMapViewModel** | — | ✅ | iOS only feature (for now) |
| **SettingsViewModel** | — | ✅ | |
| **ToolsViewModel** | — | ✅ | |

**Pattern:** macOS has zero ViewModels — all logic lives in Views. iOS has a complete MVVM layer. The iOS approach is correct for 2.0; macOS Views should be refactored to use shared ViewModels.

### 3.5 Views (Platform-Specific — NO sharing)

**macOS-specific:** SidebarView, MenuBar/*, DashboardView (macOS layout), TargetsView, TargetStatisticsView, Settings/* (7 panes), All tool views (macOS layout)

**iOS-specific:** ContentView (tab nav), Dashboard/*, NetworkMap/*, DeviceDetail/*, Settings/* (iOS layout), All tool views (iOS layout), Views/Components/* (9 reusable), Widget

---

## 4. Key Divergences Requiring Resolution

### 4.1 PingResult Mismatch (CRITICAL)

**macOS** `PingResult`: Aggregate statistics (transmitted, received, packetLoss, min/avg/max/stddev).  
**iOS** `PingResult`: Per-ping result (sequence, host, ip, ttl, time, isTimeout, method).  
**iOS** `PingStatistics`: Aggregate summary computed from individual PingResults.  

**Resolution:** iOS model is correct. Rename macOS's type to `PingAggregateResult` during migration, or (better) adopt iOS's per-result streaming model entirely.

### 4.2 TracerouteHop Field Names

**macOS:** `hostname`, `ipAddress`, `latencies`  
**iOS:** `ipAddress`, `hostname`, `times`  

Field ordering differs in init and the array is named differently. Use iOS names (`times`), they're more concise.

### 4.3 ConnectionType Raw Values

**macOS `NetMonitorShared`:** `"WiFi"`, `"Ethernet"`, `"Cellular"`, `"Unknown"`  
**iOS:** `"wifi"`, `"cellular"`, `"ethernet"`, `"none"`  

Also: macOS has `unknown`, iOS has `none`. iOS adds a `none` case explicitly.

**Resolution:** Standardize on iOS raw values (lowercase). Add a migration for any persisted macOS data that uses old raw values.

### 4.4 Continuation Safety Pattern

**macOS:** `ContinuationTracker` — class with `AtomicBool` (`OSAtomicCompareAndSwap...`).  
**iOS:** `ResumeState` — actor-based, cleaner, no unsafe operations.  

**Resolution:** Adopt `ResumeState` from NetworkScanKit. It's already proven in production across all iOS services.

### 4.5 Ping Implementation Strategy

**macOS:** Shells out to `/sbin/ping` via `ProcessPingService` + `ShellCommandRunner`. This was necessary because macOS App Sandbox blocks raw sockets.  
**iOS:** Uses `ICMPSocket` (SOCK_DGRAM/IPPROTO_ICMP — no root needed), with TCP fallback.  

**Resolution:** Adopt iOS approach. The ICMP SOCK_DGRAM socket works on macOS too (tested — it's what the iOS ICMPSocket already does). TCP fallback handles the rare case where even DGRAM sockets are blocked. `ProcessPingService` can be kept as a macOS-only fallback option but shouldn't be the primary path.

---

## 5. Migration Plan

### Phase 0: Preparation (Pre-Migration)
**Duration:** 1-2 days  
**Risk:** Low

1. **Create monorepo** at `~/Projects/NetMonitor-2.0`
2. Initialize git, copy `.gitignore` from iOS project
3. Create directory skeleton:
   ```
   NetMonitor-2.0/
   ├── Packages/
   │   ├── NetMonitorCore/
   │   │   ├── Package.swift
   │   │   ├── Sources/NetMonitorCore/
   │   │   │   ├── Services/
   │   │   │   ├── Models/
   │   │   │   └── Utilities/
   │   │   └── Tests/
   │   └── NetworkScanKit/          ← copy from iOS
   │       ├── Package.swift
   │       ├── Sources/NetworkScanKit/
   │       └── Tests/
   ├── NetMonitor-macOS/
   │   ├── App/
   │   ├── Views/
   │   ├── Platform/               ← macOS-specific services
   │   └── Resources/
   ├── NetMonitor-iOS/
   │   ├── App/
   │   ├── Views/
   │   ├── ViewModels/
   │   ├── Platform/               ← iOS-specific services  
   │   ├── Widget/
   │   └── Resources/
   ├── Tests/
   │   ├── NetMonitorCoreTests/
   │   ├── NetMonitor-macOSTests/
   │   └── NetMonitor-iOSTests/
   ├── project.yml                 ← XcodeGen config
   └── docs/
   ```
4. Set up `project.yml` (XcodeGen) with both platform targets + SPM packages
5. Verify both empty targets build

### Phase 1: Core Package — Models & Utilities
**Duration:** 2-3 days  
**Risk:** Low-Medium

Migrate the foundation that everything else depends on.

**1a. Models (from iOS, reconciled)**
| File | Source | Action |
|------|--------|--------|
| `Enums.swift` | iOS | Copy. Standardize `ConnectionType` raw values to lowercase. Add `computer`, `camera`, `storage` cases to `DeviceType` if missing. |
| `ToolModels.swift` | iOS | Copy as-is. This becomes the canonical definition for PingResult, TracerouteHop, PortScanResult, DNSRecord, etc. |
| `NetworkModels.swift` | iOS | Copy as-is. WiFiInfo, GatewayInfo, ISPInfo, NetworkStatus. |
| `NetworkError.swift` | iOS | Copy as-is. |
| `LocalDevice.swift` | iOS (richer) | Copy iOS version. Add any macOS-only fields if needed. |
| `CompanionMessage.swift` | NetMonitorShared (canonical) | Copy from NetMonitorShared, reconcile any iOS additions. |
| `ToolActivityLog.swift` | iOS | Copy as-is. |
| `ToolResult.swift` | iOS | Copy as-is. |
| `MonitoringTarget.swift` | iOS | Copy. Evaluate merging with macOS `NetworkTarget`. |
| `PairedMac.swift` | iOS | Copy as-is (companion pairing model). |
| `NetworkTarget.swift` | macOS | Copy. This is macOS's monitoring target model (SwiftData). May need reconciliation with iOS's `MonitoringTarget`. |
| `SessionRecord.swift` | macOS | Copy. Monitoring session history. |
| `MeasurementResult.swift` | macOS | Copy. Per-measurement data point. |
| `TargetCheckRequest.swift` | macOS | Copy. Request model for target checks. |
| `TargetMeasurement.swift` | macOS | Copy. Measurement result for targets. |

**1b. Utilities**
| File | Source | Action |
|------|--------|--------|
| `NetworkUtilities.swift` | iOS | Copy as-is. IPv4 network detection, host enumeration. |
| `ServiceUtilities.swift` | iOS | Copy as-is. IP validation, DNS resolution. |
| `ResumeState.swift` | NetworkScanKit | Copy to Core (used by many services outside scan engine). |

**1c. Service Protocols**
| File | Source | Action |
|------|--------|--------|
| `ServiceProtocols.swift` | iOS | Copy as-is. All protocol definitions. Remove concrete conformance extensions (those go in platform targets). |

### Phase 2: Core Package — Services
**Duration:** 3-5 days  
**Risk:** Medium

**2a. Services that share as-is (identical or trivial merge)**
| Service | Source | Action |
|---------|--------|--------|
| `ICMPSocket.swift` | Either (identical) | Copy directly. |
| `TracerouteService.swift` | iOS | Copy. Unify field name to `times`. Add `ServiceUtilities` import. |
| `WHOISService.swift` | iOS | Copy as-is. |
| `DNSLookupService.swift` | iOS | Copy as-is. Note: uses `dnssd` framework — verify available on macOS (it is). |
| `NetworkMonitorService.swift` | iOS | Copy. NWPathMonitor is cross-platform. |

**2b. Services that need adaptation**
| Service | Source | Changes Needed |
|---------|--------|----------------|
| `PingService.swift` | iOS | Copy as-is. ICMP SOCK_DGRAM works on macOS. TCP fallback covers sandbox case. Remove any NetworkScanKit-specific imports if they exist. |
| `PortScannerService.swift` | iOS | Copy. Move `ConnectionBudget` dependency to Core or make optional. Reconcile `PortState` enum vs macOS boolean. |
| `WakeOnLANService.swift` | iOS | Copy iOS version. Adapt to not require `@MainActor` in Core — move `@Observable` wrapper to platform. Core service should be a plain actor. |
| `SpeedTestService.swift` | iOS | Copy. `AtomicInt64` comes along. Adapt `@MainActor @Observable` to plain actor in Core, with `@Observable` wrapper in platform. |
| `NotificationService.swift` | Merge | Extract shared notification model. Platform-specific: macOS `NSUserNotificationCenter`, iOS `UNUserNotificationCenter`. |
| `BonjourDiscoveryService.swift` | Merge | Take macOS's richer resolution logic, iOS's cleaner async API. NetService is cross-platform. |
| `MACVendorLookupService.swift` | macOS | Copy macOS version (bundled OUI database). iOS's API-based version becomes a fallback or gets replaced. |
| `DeviceDiscoveryService.swift` | iOS | Copy. This orchestrates NetworkScanKit. Must depend on the NetworkScanKit package. |

**2c. Platform-specific services (stay in platform targets)**
| Service | Platform | Notes |
|---------|----------|-------|
| `WiFiInfoService.swift` | iOS only | Uses NEHotspotNetwork, CLLocationManager |
| `NetworkInfoService.swift` | macOS only | Uses CoreWLAN |
| `ProcessPingService.swift` | macOS fallback | Shell-based ping, kept as backup |
| `ShellCommandRunner.swift` | macOS only | Process execution utility |
| `CompanionService.swift` | macOS (server) | Multipeer/TCP server |
| `MacConnectionService.swift` | iOS (client) | Multipeer/TCP client |
| `BackgroundTaskService.swift` | iOS only | BGTaskScheduler |
| `DataExportService.swift` | iOS only (for now) | Could be shared later |
| `DataMaintenanceService.swift` | iOS only | SwiftData maintenance |
| `GatewayService.swift` | iOS | Could be shared (uses NetworkUtilities) |
| `PublicIPService.swift` | iOS | Could be shared (pure HTTP) |

### Phase 3: NetworkScanKit Migration
**Duration:** 1 day  
**Risk:** Low

NetworkScanKit already exists as an SPM package on iOS. Migration is straightforward:

1. Copy `Packages/NetworkScanKit/` from iOS repo
2. Update its `Package.swift` to reference `NetMonitorCore` if needed
3. Verify it builds for both macOS and iOS targets
4. The scan engine is platform-agnostic (BSD sockets, NWConnection) — should work on macOS without changes

### Phase 4: macOS App Target
**Duration:** 5-7 days  
**Risk:** High

This is the highest-risk phase — the macOS app has working App Store users.

1. **Create macOS target** in `project.yml`
2. **Copy all macOS Views** to `NetMonitor-macOS/Views/`
3. **Copy macOS-specific services** to `NetMonitor-macOS/Platform/`
4. **Rewire imports:** Views that used old inline services now import from `NetMonitorCore`
5. **Adapt Views to shared models:**
   - `PingResult` changes from aggregate to per-ping (biggest View change)
   - `TracerouteHop.latencies` → `.times`
   - `PortScanResult` now has `PortState` enum instead of `isOpen: Bool`
6. **Add ViewModel layer:** Extract logic from macOS Views into ViewModels (can reuse iOS ViewModels where applicable, or create macOS-specific ones)
7. **Test thoroughly** — every tool, every view, every edge case
8. **Preserve entitlements:** macOS has specific sandbox entitlements that must carry over

### Phase 5: iOS App Target
**Duration:** 2-3 days  
**Risk:** Low-Medium

iOS is closer to the target architecture already.

1. **Create iOS target** in `project.yml`
2. **Copy all iOS Views** to `NetMonitor-iOS/Views/`
3. **Copy iOS ViewModels** to `NetMonitor-iOS/ViewModels/`
4. **Copy iOS-specific services** to `NetMonitor-iOS/Platform/`
5. **Rewire imports** to use `NetMonitorCore` and `NetworkScanKit` packages
6. **Copy Widget** to `NetMonitor-iOS/Widget/`
7. **Copy tests** — unit tests to `Tests/`, UI tests to `NetMonitor-iOS/`
8. **Verify everything builds and passes tests**

### Phase 6: Cleanup & Verification
**Duration:** 2-3 days  
**Risk:** Low

1. Remove all dead code / duplicates
2. Run full test suite on both platforms
3. Verify macOS App Store build (archive, notarize)
4. Verify iOS App Store build (archive)
5. Compare feature parity
6. Update CI/CD if applicable
7. Archive old repos (don't delete — keep for reference)

---

## 6. File-by-File Migration Reference

### Into `Packages/NetMonitorCore/Sources/NetMonitorCore/`

```
Models/
├── CompanionMessage.swift        ← from NetMonitorShared (reconciled)
├── Enums.swift                   ← from iOS (standardized raw values)
├── LocalDevice.swift             ← from iOS (richer version)
├── MonitoringTarget.swift        ← from iOS (evaluate merge with NetworkTarget)
├── NetworkError.swift            ← from iOS
├── NetworkModels.swift           ← from iOS
├── NetworkTarget.swift           ← from macOS (monitoring)
├── SessionRecord.swift           ← from macOS (monitoring)
├── MeasurementResult.swift       ← from macOS (monitoring)
├── TargetCheckRequest.swift      ← from macOS
├── TargetMeasurement.swift       ← from macOS
├── ToolActivityLog.swift         ← from iOS
├── ToolModels.swift              ← from iOS (PingResult, TracerouteHop, etc.)
├── ToolResult.swift              ← from iOS
└── PairedMac.swift               ← from iOS

Services/
├── BonjourDiscoveryService.swift ← merged (macOS resolution + iOS async API)
├── DeviceDiscoveryService.swift  ← from iOS (NetworkScanKit integration)
├── DNSLookupService.swift        ← from iOS
├── ICMPSocket.swift              ← from either (identical)
├── MACVendorLookupService.swift  ← from macOS (bundled OUI DB)
├── NetworkMonitorService.swift   ← from iOS
├── NotificationService.swift     ← merged (shared model + platform protocols)
├── PingService.swift             ← from iOS (ICMP-first + TCP fallback)
├── PortScannerService.swift      ← from iOS (with ConnectionBudget)
├── ServiceProtocols.swift        ← from iOS (protocols only, no conformances)
├── SpeedTestService.swift        ← from iOS (parallel streams)
├── TracerouteService.swift       ← from iOS (unified field names)
├── WakeOnLANService.swift        ← from iOS (adapted to actor)
└── WHOISService.swift            ← from iOS

Utilities/
├── NetworkUtilities.swift        ← from iOS
├── ResumeState.swift             ← from NetworkScanKit
└── ServiceUtilities.swift        ← from iOS
```

### Into `NetMonitor-macOS/Platform/`

```
NetworkInfoService.swift          ← macOS (CoreWLAN)
ProcessPingService.swift          ← macOS (shell fallback)
ShellCommandRunner.swift          ← macOS (Process execution)
CompanionService.swift            ← macOS (server side)
CompanionMessageHandler.swift     ← macOS
MonitoringSession.swift           ← macOS
HTTPMonitorService.swift          ← macOS
ICMPMonitorService.swift          ← macOS
TCPMonitorService.swift           ← macOS
StatisticsService.swift           ← macOS
ISPLookupService.swift            ← macOS
DefaultTargetsProvider.swift      ← macOS
DeviceDiscoveryCoordinator.swift  ← macOS
DeviceNameResolver.swift          ← macOS (if different from iOS)
ARPScannerService.swift           ← macOS (different from iOS scan engine)
Logging.swift                     ← macOS
```

### Into `NetMonitor-iOS/Platform/`

```
WiFiInfoService.swift             ← iOS (NEHotspotNetwork)
MacConnectionService.swift        ← iOS (companion client)
BackgroundTaskService.swift       ← iOS
DataExportService.swift           ← iOS
DataMaintenanceService.swift      ← iOS
GatewayService.swift              ← iOS (could be promoted to Core later)
PublicIPService.swift              ← iOS (could be promoted to Core later)
AppSettings.swift                 ← iOS
TargetManager.swift               ← iOS
```

---

## 7. Risk Assessment

### High Risk
| Risk | Impact | Mitigation |
|------|--------|------------|
| macOS App Store regression | Users see broken update | Feature-freeze macOS 1.x while migrating. Ship 2.0 only after exhaustive testing. Keep old repo as fallback. |
| Model migration breaks SwiftData persistence | User data loss | Version the SwiftData schema. Write migration from v1→v2 `LocalDevice`. Test with real user data. |
| Entitlement/signing issues | App rejected or crashes | Document every entitlement from both projects. Test with production signing before submission. |

### Medium Risk
| Risk | Impact | Mitigation |
|------|--------|------------|
| `PingResult` type change breaks macOS Views | Compile errors, logic bugs | Migrate incrementally — add iOS PingResult alongside old type, then migrate Views one at a time. |
| `ConnectionType` raw value change | Decoding failures | Add `init(from decoder:)` that handles both old and new raw values. |
| XcodeGen complexity | Build failures | Start with minimal `project.yml`, add targets incrementally. Commit after each working state. |
| Test coverage gaps | Regressions | iOS has 25+ test files. macOS has few/none. Write tests for Core package before migrating. |

### Low Risk
| Risk | Impact | Mitigation |
|------|--------|------------|
| NetworkScanKit on macOS | Scan engine may behave differently | It's BSD sockets + NWConnection — should be identical. Test ARP cache parsing (may differ). |
| Theme/UI consistency | Visual glitches | Keep themes platform-specific initially. Unify design tokens later. |
| Git history loss | Harder to bisect bugs | Use `git filter-repo` or `git subtree` to preserve meaningful history. Or accept fresh history for 2.0. |

---

## 8. What Can Be Shared As-Is vs. Needs Adaptation

### Share As-Is (Copy Directly)
- `ICMPSocket.swift` — byte-for-byte identical
- `WHOISService.swift` — iOS only, no macOS equivalent to reconcile
- `DNSLookupService.swift` — iOS only
- `NetworkUtilities.swift` — pure Foundation
- `ServiceUtilities.swift` — pure Foundation
- `ToolModels.swift` — pure data structs
- `NetworkModels.swift` — pure data structs
- `NetworkError.swift` — pure enum
- `ToolActivityLog.swift` — pure model
- `ToolResult.swift` — pure model

### Needs Minor Adaptation
- `TracerouteService.swift` — rename `latencies`→`times` (or vice versa)
- `NetworkMonitorService.swift` — minor API reconciliation
- `PingService.swift` — remove NetworkScanKit import if unused
- `PortScannerService.swift` — ensure `ConnectionBudget` is available

### Needs Significant Adaptation
- `WakeOnLANService.swift` — extract actor core from `@MainActor @Observable` wrapper
- `SpeedTestService.swift` — extract actor core from `@MainActor @Observable` wrapper
- `BonjourDiscoveryService.swift` — merge two implementations
- `MACVendorLookupService.swift` — port macOS bundled DB to cross-platform
- `NotificationService.swift` — shared notification model, platform-specific delivery
- `Enums.swift` — reconcile raw values, merge cases
- `LocalDevice.swift` — reconcile schemas, write SwiftData migration
- `CompanionMessage.swift` — re-unify diverged copies

### Must Remain Platform-Specific
- `WiFiInfoService.swift` (iOS) / `NetworkInfoService.swift` (macOS) — different frameworks
- `CompanionService.swift` (macOS server) / `MacConnectionService.swift` (iOS client)
- `ProcessPingService.swift` / `ShellCommandRunner.swift` (macOS only)
- `BackgroundTaskService.swift` (iOS only)
- All Views (different layouts, navigation paradigms)
- `MenuBar*` (macOS only)
- Widget (iOS only)

---

## 9. Open Questions

1. **Repo location:** New repo (`NetMonitor-2.0`) or convert existing macOS repo (`NetMonitor`)? 
   - Recommendation: New repo. Avoids risk to shipping macOS app. Can archive both old repos.

2. **Bundle IDs / App Store Connect:** Keep existing bundle IDs (`com.jbcrane.NetMonitor`, `com.jbcrane.Netmonitor`) or unify?
   - Must keep existing IDs for App Store continuity. Different bundle IDs per platform is fine.

3. **When to start:** After iOS 1.0 is approved? Or begin now?
   - Recommendation: Begin planning now, start Phase 0 after iOS 1.0 approval. No code changes to shipping apps until 2.0 is ready.

4. **macOS monitoring feature on iOS?** The macOS app has a rich monitoring feature (targets, sessions, statistics). Should this come to iOS 2.0?
   - Recommendation: Yes, as a 2.0 feature. The shared model layer makes this natural.

5. **ViewModels shared or per-platform?** iOS has a full ViewModel layer; macOS has none.
   - Recommendation: Keep ViewModels per-platform initially (they depend on platform Views). Extract shared business logic into the service layer instead. ViewModels can be unified later if patterns converge.

---

## 10. Success Criteria

- [ ] Single `xcodegen generate` produces working Xcode project with both targets
- [ ] iOS app builds, runs, and passes all existing tests
- [ ] macOS app builds, runs, and all tools function correctly
- [ ] Zero duplicate service files between platforms
- [ ] `NetMonitorCore` package builds for both iOS and macOS
- [ ] `NetworkScanKit` builds for both iOS and macOS
- [ ] SwiftData migration preserves existing user data on both platforms
- [ ] Both apps can be archived and submitted to App Store
- [ ] Companion pairing still works between macOS and iOS

---

## 11. Estimated Timeline

| Phase | Duration | Cumulative |
|-------|----------|------------|
| Phase 0: Preparation | 1-2 days | 2 days |
| Phase 1: Core Models & Utils | 2-3 days | 5 days |
| Phase 2: Core Services | 3-5 days | 10 days |
| Phase 3: NetworkScanKit | 1 day | 11 days |
| Phase 4: macOS Target | 5-7 days | 18 days |
| Phase 5: iOS Target | 2-3 days | 21 days |
| Phase 6: Cleanup & Verify | 2-3 days | 24 days |

**Total: ~3-4 weeks of focused work**

This can be parallelized — Phase 4 and Phase 5 are independent once Core is done.

---

*This document should be reviewed and updated as migration progresses. Each phase completion should be noted here with date and any deviations from plan.*
